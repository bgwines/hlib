<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Zora.List</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Zora-List.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Zora-List.html">Source</a></li><li><a href="http://hackage.haskell.org/package/Zora">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">Zora-1.1.18: Graphing library wrapper + assorted useful functions</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) Brett Wines 2014</td></tr><tr><th>License</th><td>BSD-style</td></tr><tr><th>Maintainer</th><td>bgwines@cs.stanford.edu</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Zora.List</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Partitioning</a></li><li><a href="#g:2">List transformations</a></li><li><a href="#g:3">Permutations, combinations, and cycles</a></li><li><a href="#g:4">Operations with two lists</a></li><li><a href="#g:5">Sublists</a></li><li><a href="#g:6">Sorting</a></li><li><a href="#g:7">Predicates</a></li><li><a href="#g:8">Assorted functions</a></li><li><a href="#g:9">Tuples</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Assorted functions on lists.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:partition_with_block_size">partition_with_block_size</a> ::  <a href="http://hackage.haskell.org/package/base/docs/Data-Int.html#t:Int">Int</a> -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:partition_into_k">partition_into_k</a> ::  <a href="http://hackage.haskell.org/package/base/docs/Data-Int.html#t:Int">Int</a> -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:powerpartition">powerpartition</a> ::  [a] -&gt; [[[a]]]</li><li class="src short"><a href="#v:uniqueify">uniqueify</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:pairify">pairify</a> ::  [a] -&gt; [(a, a)]</li><li class="src short"><a href="#v:decyclify">decyclify</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:shuffle">shuffle</a> :: <span class="keyword">forall</span> a. <a href="http://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; [a]</li><li class="src short"><a href="#v:powerset">powerset</a> ::  [a] -&gt; [[a]]</li><li class="src short"><a href="#v:permutations">permutations</a> ::  [a] -&gt; [[a]]</li><li class="src short"><a href="#v:subsets_of_size">subsets_of_size</a> ::  [a] -&gt; <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; [[a]]</li><li class="src short"><a href="#v:subsets_of_size_with_replacement">subsets_of_size_with_replacement</a> ::  <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:cycles">cycles</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:has_cycles">has_cycles</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:diff_infinite">diff_infinite</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:merge">merge</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:merge_by">merge_by</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; (a -&gt; a -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ordering">Ordering</a>) -&gt; [a] -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:zip_while">zip_while</a> ::  (a -&gt; b -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; [a] -&gt; [b] -&gt; [(a, b)]</li><li class="src short"><a href="#v:remove_at_index">remove_at_index</a> ::  <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:subseq">subseq</a> ::  <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:take_while_keep_last">take_while_keep_last</a> ::  (a -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:take_while_and_rest">take_while_and_rest</a> ::  (a -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a])</li><li class="src short"><a href="#v:find_and_rest">find_and_rest</a> ::  (a -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; [a] -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Maybe.html#t:Maybe">Maybe</a> (a, [a])</li><li class="src short"><a href="#v:subsequences">subsequences</a> ::  [a] -&gt; [[a]]</li><li class="src short"><a href="#v:contiguous_subsequences">contiguous_subsequences</a> ::  [a] -&gt; [[a]]</li><li class="src short"><a href="#v:contiguous_subsequences_of_length">contiguous_subsequences_of_length</a> :: <a href="http://hackage.haskell.org/package/base/docs/Text-Show.html#t:Show">Show</a> a =&gt; <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; [a] -&gt; [[a]]</li><li class="src short"><a href="#v:is_sorted">is_sorted</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:mergesort">mergesort</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:is_palindrome">is_palindrome</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq">Eq</a> e =&gt; [e] -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:contains_duplicates">contains_duplicates</a> :: <span class="keyword">forall</span> a. <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:bsearch">bsearch</a> :: (<a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ordering">Ordering</a>) -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a></li><li class="src short"><a href="#v:bsearch_1st_geq">bsearch_1st_geq</a> :: (<a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ordering">Ordering</a>) -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a></li><li class="src short"><a href="#v:elem_counts">elem_counts</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; [(a, <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a>)]</li><li class="src short"><a href="#v:elem_counts_by">elem_counts_by</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> b =&gt; (a -&gt; b) -&gt; [a] -&gt; [(a, <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a>)]</li><li class="src short"><a href="#v:running_bests">running_bests</a> :: <span class="keyword">forall</span> a. <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:running_bests_by">running_bests_by</a> :: <span class="keyword">forall</span> a. <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; (a -&gt; a -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ordering">Ordering</a>) -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:-60--36--42--62-">(&lt;$*&gt;)</a> :: <a href="http://hackage.haskell.org/package/base/docs/Control-Applicative.html#t:Applicative">Applicative</a> f =&gt; (a -&gt; a -&gt; b) -&gt; f a -&gt; f b</li><li class="src short"><a href="#v:-36--36-">($$)</a> ::  (a -&gt; a -&gt; b) -&gt; a -&gt; b</li><li class="src short"><a href="#v:interleave">interleave</a> ::  [a] -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:passing_index_elems">passing_index_elems</a> ::  (<a href="http://hackage.haskell.org/package/base/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:count">count</a> ::  (a -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; [a] -&gt; <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a></li><li class="src short"><a href="#v:map_keep">map_keep</a> ::  (a -&gt; b) -&gt; [a] -&gt; [(a, b)]</li><li class="src short"><a href="#v:maximum_with_index">maximum_with_index</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; (a, <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a>)</li><li class="src short"><a href="#v:minimum_with_index">minimum_with_index</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; (a, <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a>)</li><li class="src short"><a href="#v:maxima_by">maxima_by</a> ::  (a -&gt; a -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ordering">Ordering</a>) -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:minima_by">minima_by</a> ::  (a -&gt; a -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ordering">Ordering</a>) -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:length-39-">length'</a> ::  [a] -&gt; <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a></li><li class="src short"><a href="#v:drop-39-">drop'</a> ::  <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:take-39-">take'</a> ::  <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:cons">cons</a> ::  a -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:snoc">snoc</a> ::  a -&gt; [a] -&gt; [a]</li><li class="src short"><a href="#v:map_fst">map_fst</a> ::  (a -&gt; c) -&gt; (a, b) -&gt; (c, b)</li><li class="src short"><a href="#v:map_snd">map_snd</a> ::  (b -&gt; c) -&gt; (a, b) -&gt; (a, c)</li><li class="src short"><a href="#v:map_pair">map_pair</a> ::  (a -&gt; c) -&gt; (b -&gt; d) -&gt; (a, b) -&gt; (c, d)</li><li class="src short"><a href="#v:map_pair_same">map_pair_same</a> ::  (a -&gt; b) -&gt; (a, a) -&gt; (b, b)</li><li class="src short"><a href="#v:map_triple">map_triple</a> ::  (a -&gt; d) -&gt; (b -&gt; e) -&gt; (c -&gt; f) -&gt; (a, b, c) -&gt; (d, e, f)</li><li class="src short"><a href="#v:zip_with_pair">zip_with_pair</a> ::  (a -&gt; c -&gt; e) -&gt; (b -&gt; d -&gt; f) -&gt; (a, b) -&gt; (c, d) -&gt; (e, f)</li><li class="src short"><a href="#v:zip_with_pair_same">zip_with_pair_same</a> ::  (a -&gt; b -&gt; c) -&gt; (a, a) -&gt; (b, b) -&gt; (c, c)</li><li class="src short"><a href="#v:fst3">fst3</a> ::  (a, b, c) -&gt; a</li><li class="src short"><a href="#v:snd3">snd3</a> ::  (a, b, c) -&gt; b</li><li class="src short"><a href="#v:trd3">trd3</a> ::  (a, b, c) -&gt; c</li><li class="src short"><a href="#v:pair_op">pair_op</a> ::  (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c</li><li class="src short"><a href="#v:triple_op">triple_op</a> ::  (a -&gt; b -&gt; c -&gt; d) -&gt; (a, b, c) -&gt; d</li></ul></div><div id="interface"><h1 id="g:1">Partitioning</h1><div class="top"><p class="src"><a name="v:partition_with_block_size" class="def">partition_with_block_size</a> ::  <a href="http://hackage.haskell.org/package/base/docs/Data-Int.html#t:Int">Int</a> -&gt; [a] -&gt; [[a]] <a href="src/Zora-List.html#partition_with_block_size" class="link">Source</a></p><div class="doc"><p><em>O(n)</em> Partitions the given list into blocks of the specified length. Truncation behaves as follows:</p><pre>partition_with_block_size 3 [1..10] == [[1,2,3],[4,5,6],[7,8,9],[10]]</pre></div></div><div class="top"><p class="src"><a name="v:partition_into_k" class="def">partition_into_k</a> ::  <a href="http://hackage.haskell.org/package/base/docs/Data-Int.html#t:Int">Int</a> -&gt; [a] -&gt; [[a]] <a href="src/Zora-List.html#partition_into_k" class="link">Source</a></p><div class="doc"><p><em>O(n)</em> Partitions the given list into <em>k</em> blocks. Truncation behavior is best described by example:</p><pre>partition_into_k  3 [1..9]  == [[1,2,3],[4,5,6],[7,8,9]]
partition_into_k  3 [1..10] == [[1,2,3,4],[5,6,7,8],[9,10]]
partition_into_k  3 [1..11] == [[1,2,3,4],[5,6,7,8],[9,10,11]]
partition_into_k  3 [1..12] == [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
partition_into_k  3 [1..13] == [[1,2,3,4,5],[6,7,8,9,10],[11,12,13]]</pre></div></div><div class="top"><p class="src"><a name="v:powerpartition" class="def">powerpartition</a> ::  [a] -&gt; [[[a]]] <a href="src/Zora-List.html#powerpartition" class="link">Source</a></p><div class="doc"><p><em>O(B(n))</em>, where <em>B(n)</em> is the <em>n</em>^th <a href="http://en.wikipedia.org/wiki/Bell_number">Bell number</a>. Computes all partitions of the given list. For example,</p><pre>powerpartition [1..3] == [[[1],[2],[3]], [[1,2],[3]], [[2],[1,3]], [[1],[2,3]], [[1,2,3]]]</pre></div></div><h1 id="g:2">List transformations</h1><div class="top"><p class="src"><a name="v:uniqueify" class="def">uniqueify</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; [a] <a href="src/Zora-List.html#uniqueify" class="link">Source</a></p><div class="doc"><p><em>O(n log(n))</em> Removes duplicate elements. Like <code><a href="http://hackage.haskell.org/package/base/docs/Data-List.html#v:nub">nub</a></code>, but for <code><a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a></code> types, so it can be faster.</p></div></div><div class="top"><p class="src"><a name="v:pairify" class="def">pairify</a> ::  [a] -&gt; [(a, a)] <a href="src/Zora-List.html#pairify" class="link">Source</a></p><div class="doc"><p><em>O(n)</em> Zips the list up into pairs. For example,</p><pre>pairify [1..6] == [(1,2), (3,4), (5,6)]
pairify [1..5] == [(1,2), (3,4)]</pre></div></div><div class="top"><p class="src"><a name="v:decyclify" class="def">decyclify</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; [a] <a href="src/Zora-List.html#decyclify" class="link">Source</a></p><div class="doc"><p><em>O(l m)</em>, where <em>l</em> is the cycle length and <em>m</em> is the index of the start of the cycle. If the list contains no cycles, then the runtime is <em>O(n)</em>.</p><p>NOTE: this function will only find cycles in a list can be the output of an iterated function -- that is, no element may be succeeded by two separate elements (e.g. [2,3,2,4]).</p></div></div><div class="top"><p class="src"><a name="v:shuffle" class="def">shuffle</a> :: <span class="keyword">forall</span> a. <a href="http://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; [a] <a href="src/Zora-List.html#shuffle" class="link">Source</a></p><div class="doc"><p><em>O(n log(n))</em> Shuffles the given list. The second parameter is the seed for the random number generator that backs the shuffle.</p></div></div><h1 id="g:3">Permutations, combinations, and cycles</h1><div class="top"><p class="src"><a name="v:powerset" class="def">powerset</a> ::  [a] -&gt; [[a]] <a href="src/Zora-List.html#powerset" class="link">Source</a></p><div class="doc"><p><em>O(2^n)</em> Computes the powerset of the given list.</p></div></div><div class="top"><p class="src"><a name="v:permutations" class="def">permutations</a> ::  [a] -&gt; [[a]] <a href="src/Zora-List.html#permutations" class="link">Source</a></p><div class="doc"><p><em>O(n!)</em> Computes all permutations of the given list.</p></div></div><div class="top"><p class="src"><a name="v:subsets_of_size" class="def">subsets_of_size</a> ::  [a] -&gt; <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; [[a]] <a href="src/Zora-List.html#subsets_of_size" class="link">Source</a></p><div class="doc"><p><em>O(2^k)</em> Generates all subsets of the given list of size <em>k</em>.</p></div></div><div class="top"><p class="src"><a name="v:subsets_of_size_with_replacement" class="def">subsets_of_size_with_replacement</a> ::  <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; [a] -&gt; [[a]] <a href="src/Zora-List.html#subsets_of_size_with_replacement" class="link">Source</a></p><div class="doc"><p><em>O(n^m)</em> Computes all sets comprised of elements in the given list, where the elements may be used multiple times, where <code>n</code> is the size of the given list and <code>m</code> is the size of the sets to generate. For example,</p><pre>subsets_of_size_with_replacement 3 [1,2] == [[1,1,1],[2,1,1],[1,2,1],[2,2,1],[1,1,2],[2,1,2],[1,2,2],[2,2,2]]</pre></div></div><div class="top"><p class="src"><a name="v:cycles" class="def">cycles</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; [[a]] <a href="src/Zora-List.html#cycles" class="link">Source</a></p><div class="doc"><p><em>O(n)</em> Generates all cycles of a given list. For example,</p><pre>cycles [1..3] == [[2,3,1],[3,1,2],[1,2,3]]</pre></div></div><div class="top"><p class="src"><a name="v:has_cycles" class="def">has_cycles</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq">Eq</a> a =&gt; [a] -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a> <a href="src/Zora-List.html#has_cycles" class="link">Source</a></p><div class="doc"><p><em>O(l m)</em>, where <em>l</em> is the cycle length and <em>m</em> is the index of the start of the cycle. If the list contains no cycles, then the runtime is <em>O(n)</em>.</p></div></div><h1 id="g:4">Operations with two lists</h1><div class="top"><p class="src"><a name="v:diff_infinite" class="def">diff_infinite</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; [a] -&gt; [a] <a href="src/Zora-List.html#diff_infinite" class="link">Source</a></p><div class="doc"><p>Given two infinite sorted lists, generates a list of elements in the first but not the second. Implementation from <a href="http://en.literateprograms.org/Sieve_of_Eratosthenes_(Haskell)">http://en.literateprograms.org/Sieve_of_Eratosthenes_(Haskell)</a>.</p></div></div><div class="top"><p class="src"><a name="v:merge" class="def">merge</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; [a] -&gt; [a] <a href="src/Zora-List.html#merge" class="link">Source</a></p><div class="doc"><p><em>O(max(n, m))</em> Merges the two given sorted lists of respective lengths <em>n</em> and <em>m</em>. A special case of <code><a href="Zora-List.html#v:merge_by">merge_by</a></code> where the comparison function is <code><a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#v:compare">compare</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:merge_by" class="def">merge_by</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; (a -&gt; a -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ordering">Ordering</a>) -&gt; [a] -&gt; [a] -&gt; [a] <a href="src/Zora-List.html#merge_by" class="link">Source</a></p><div class="doc"><p><em>O(max(n, m))</em> Merges the two given sorted lists of respective lengths <em>n</em> and <em>m</em>, comparing elements in between the two lists with the given comparator function.</p></div></div><div class="top"><p class="src"><a name="v:zip_while" class="def">zip_while</a> ::  (a -&gt; b -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; [a] -&gt; [b] -&gt; [(a, b)] <a href="src/Zora-List.html#zip_while" class="link">Source</a></p><div class="doc"><p><em>O(min(n, m))</em> Zips the two given lists of respective lengths <em>n</em> and <em>m</em> as long as the pairs satisfy the given predicate function.</p></div></div><h1 id="g:5">Sublists</h1><div class="top"><p class="src"><a name="v:remove_at_index" class="def">remove_at_index</a> ::  <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; [a] -&gt; [a] <a href="src/Zora-List.html#remove_at_index" class="link">Source</a></p><div class="doc"><p><em>O(n)</em> Removes an element at the specified index in the given list.</p></div></div><div class="top"><p class="src"><a name="v:subseq" class="def">subseq</a> ::  <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; [a] -&gt; [a] <a href="src/Zora-List.html#subseq" class="link">Source</a></p><div class="doc"><p><em>O(n)</em> Returns the subsequence of the given length at starting at index <em>i</em> of length <em>m</em>. For example,</p><pre>subseq 4 5 [1..20] == [5,6,7,8,9]</pre></div></div><div class="top"><p class="src"><a name="v:take_while_keep_last" class="def">take_while_keep_last</a> ::  (a -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="src/Zora-List.html#take_while_keep_last" class="link">Source</a></p><div class="doc"><p><em>(O(n))</em> Identical to <code><a href="http://hackage.haskell.org/package/base/docs/Data-List.html#v:takeWhile">takeWhile</a></code>, but also contains the first element to satisfy the given predicate function. For example:</p><pre>take_while_keep_last (&lt;3) [1..] == [1,2,3]</pre></div></div><div class="top"><p class="src"><a name="v:take_while_and_rest" class="def">take_while_and_rest</a> ::  (a -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a]) <a href="src/Zora-List.html#take_while_and_rest" class="link">Source</a></p><div class="doc"><p><em>(O(n))</em> Returns a pair where the first element is identical to what <code><a href="http://hackage.haskell.org/package/base/docs/Data-List.html#v:takeWhile">takeWhile</a></code> returns and the second element is the rest of the list</p><pre>take_while_and_rest (&lt;3) [1..10] == ([1,2],[3,4,5,6,7,8,9,10])</pre></div></div><div class="top"><p class="src"><a name="v:find_and_rest" class="def">find_and_rest</a> ::  (a -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; [a] -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Maybe.html#t:Maybe">Maybe</a> (a, [a]) <a href="src/Zora-List.html#find_and_rest" class="link">Source</a></p><div class="doc"><p><em>O(n)</em> Like <code>Data.List.Find</code>, but returns a Maybe 2-tuple, instead, where the second element of the pair is the elements in the list after the first element of the pair.</p><pre>(find_and_rest ((==) 3) [1..10]) == Just (3, [4..10])</pre></div></div><div class="top"><p class="src"><a name="v:subsequences" class="def">subsequences</a> ::  [a] -&gt; [[a]] <a href="src/Zora-List.html#subsequences" class="link">Source</a></p><div class="doc"><p><em>(O(2^n))</em> Returns all subsequences (contiguous and noncontiguous)</p></div></div><div class="top"><p class="src"><a name="v:contiguous_subsequences" class="def">contiguous_subsequences</a> ::  [a] -&gt; [[a]] <a href="src/Zora-List.html#contiguous_subsequences" class="link">Source</a></p><div class="doc"><p><em>(O(n^2))</em> Returns all contiguous subsequences.</p></div></div><div class="top"><p class="src"><a name="v:contiguous_subsequences_of_length" class="def">contiguous_subsequences_of_length</a> :: <a href="http://hackage.haskell.org/package/base/docs/Text-Show.html#t:Show">Show</a> a =&gt; <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; [a] -&gt; [[a]] <a href="src/Zora-List.html#contiguous_subsequences_of_length" class="link">Source</a></p><div class="doc"><p><em>O(n)</em> Retuns all contiguous subsequences of the given length. E.g.:</p><pre>contiguous_subsequences_of_length 3 &quot;1234567890&quot;</pre><dl><dt>&quot;123&quot;,&quot;234&quot;,&quot;345&quot;,&quot;456&quot;,&quot;567&quot;,&quot;678&quot;,&quot;789&quot;,&quot;890&quot;</dt><dd></dd></dl></div></div><h1 id="g:6">Sorting</h1><div class="top"><p class="src"><a name="v:is_sorted" class="def">is_sorted</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a> <a href="src/Zora-List.html#is_sorted" class="link">Source</a></p><div class="doc"><p><em>O(n)</em> Returns whether the given list is sorted.</p></div></div><div class="top"><p class="src"><a name="v:mergesort" class="def">mergesort</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; [a] <a href="src/Zora-List.html#mergesort" class="link">Source</a></p><div class="doc"><p><em>O(n log(n))</em> Sorts the given list.</p></div></div><h1 id="g:7">Predicates</h1><div class="top"><p class="src"><a name="v:is_palindrome" class="def">is_palindrome</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq">Eq</a> e =&gt; [e] -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a> <a href="src/Zora-List.html#is_palindrome" class="link">Source</a></p><div class="doc"><p><em>O(n)</em> Returns whether the given list is a palindrome.</p></div></div><div class="top"><p class="src"><a name="v:contains_duplicates" class="def">contains_duplicates</a> :: <span class="keyword">forall</span> a. <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a> <a href="src/Zora-List.html#contains_duplicates" class="link">Source</a></p><div class="doc"><p><em>O(n log(n))</em> Returns whether the given list contains any element more than once.</p></div></div><h1 id="g:8">Assorted functions</h1><div class="top"><p class="src"><a name="v:bsearch" class="def">bsearch</a> :: (<a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ordering">Ordering</a>) -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> <a href="src/Zora-List.html#bsearch" class="link">Source</a></p><div class="doc"><p><em>O(f log k)</em>, where k is the returnvalue, and f is the runtime of the input function on the lowest power of 2 above the returnvalue.</p></div></div><div class="top"><p class="src"><a name="v:bsearch_1st_geq" class="def">bsearch_1st_geq</a> :: (<a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ordering">Ordering</a>) -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> <a href="src/Zora-List.html#bsearch_1st_geq" class="link">Source</a></p><div class="doc"><p><em>O(f log k)</em>, where k is the returnvalue, and f is the runtime of the input function on the lowest power of 2 above the returnvalue.</p></div></div><div class="top"><p class="src"><a name="v:elem_counts" class="def">elem_counts</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; [(a, <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a>)] <a href="src/Zora-List.html#elem_counts" class="link">Source</a></p><div class="doc"><p><em>O(nlog(n))</em> Counts the number of time each element appears in the given list. For example:</p><pre>elem_counts [1,2,1,4] == [(1,2),(2,1),(4,1)]</pre></div></div><div class="top"><p class="src"><a name="v:elem_counts_by" class="def">elem_counts_by</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> b =&gt; (a -&gt; b) -&gt; [a] -&gt; [(a, <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a>)] <a href="src/Zora-List.html#elem_counts_by" class="link">Source</a></p><div class="doc"><p><em>O(nlog(n))</em> Counts the number of time each element appears in the given list. For example:</p><pre>elem_counts [1,2,1,4] == [(1,2),(2,1),(4,1)]</pre></div></div><div class="top"><p class="src"><a name="v:running_bests" class="def">running_bests</a> :: <span class="keyword">forall</span> a. <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; [a] <a href="src/Zora-List.html#running_bests" class="link">Source</a></p><div class="doc"><p><em>O(n)</em> Returns the noncontiguous sublist of elements greater than all previous elements. For example:</p><pre>running_bests [1,3,2,4,6,5] == [1,3,4,6]</pre></div></div><div class="top"><p class="src"><a name="v:running_bests_by" class="def">running_bests_by</a> :: <span class="keyword">forall</span> a. <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; (a -&gt; a -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ordering">Ordering</a>) -&gt; [a] -&gt; [a] <a href="src/Zora-List.html#running_bests_by" class="link">Source</a></p><div class="doc"><p><em>O(n)</em> Returns the noncontiguous sublist of elements greater than all previous elements, where &quot;greater&quot; is determined by the provided comparison function. For example:</p><pre>running_bests_by (Data.Ord.comparing length) [[1],[3,3,3],[2,2]] == [[1],[3,3,3]]</pre></div></div><div class="top"><p class="src"><a name="v:-60--36--42--62-" class="def">(&lt;$*&gt;)</a> :: <a href="http://hackage.haskell.org/package/base/docs/Control-Applicative.html#t:Applicative">Applicative</a> f =&gt; (a -&gt; a -&gt; b) -&gt; f a -&gt; f b <a href="src/Zora-List.html#%3C%24%2A%3E" class="link">Source</a></p><div class="doc"><p>Shorthand for applicative functors:</p><pre>f &lt;$*&gt; l = f &lt;$&gt; l &lt;*&gt; l</pre></div></div><div class="top"><p class="src"><a name="v:-36--36-" class="def">($$)</a> ::  (a -&gt; a -&gt; b) -&gt; a -&gt; b <a href="src/Zora-List.html#%24%24" class="link">Source</a></p><div class="doc"><p>Shorthand for applying the same parameter twice.</p><pre>f $$ x = f x x</pre></div></div><div class="top"><p class="src"><a name="v:interleave" class="def">interleave</a> ::  [a] -&gt; [a] -&gt; [a] <a href="src/Zora-List.html#interleave" class="link">Source</a></p><div class="doc"><p><em>O(min(n, m))</em> Interleaves elements from the two given lists of respective lengths <code>n</code> and <code>m</code> in an alternating fashion. For example:</p><pre>interleave [1,3,5,7] [2,4,6,8] == [1,2,3,4,5,6,7,8]</pre><pre>interleave [1,3,5,7] [2,4,6] == [1,2,3,4,5,6,7]</pre><pre>interleave [1,3,5] [2,4,6,8] == [1,2,3,4,5,6,8]</pre></div></div><div class="top"><p class="src"><a name="v:passing_index_elems" class="def">passing_index_elems</a> ::  (<a href="http://hackage.haskell.org/package/base/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="src/Zora-List.html#passing_index_elems" class="link">Source</a></p><div class="doc"><p><em>O(nf)</em> Filters a list of length <code>n</code> leaving elemnts the indices of which satisfy the given predicate function, which has runtime <code>f</code>.</p></div></div><div class="top"><p class="src"><a name="v:count" class="def">count</a> ::  (a -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; [a] -&gt; <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> <a href="src/Zora-List.html#count" class="link">Source</a></p><div class="doc"><p><em>O(n)</em> counts the number of elements in a list that satisfy a given predicate function.</p></div></div><div class="top"><p class="src"><a name="v:map_keep" class="def">map_keep</a> ::  (a -&gt; b) -&gt; [a] -&gt; [(a, b)] <a href="src/Zora-List.html#map_keep" class="link">Source</a></p><div class="doc"><p><em>O(n)</em> Maps the given function over the list while keeping the original list. For example:</p><pre>map_keep chr [97..100] == [(97,'a'),(98,'b'),(99,'c'),(100,'d')]</pre></div></div><div class="top"><p class="src"><a name="v:maximum_with_index" class="def">maximum_with_index</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; (a, <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a>) <a href="src/Zora-List.html#maximum_with_index" class="link">Source</a></p><div class="doc"><p><em>O(n)</em> Finds the maximum element of the given list and returns a pair of it and the index at which it occurs (if the maximum element occurs multiple times, behavior is identical to that of <code><a href="http://hackage.haskell.org/package/base/docs/Data-List.html#v:maximumBy">maximumBy</a></code>). The list must be finite and non-empty.</p></div></div><div class="top"><p class="src"><a name="v:minimum_with_index" class="def">minimum_with_index</a> :: <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ord">Ord</a> a =&gt; [a] -&gt; (a, <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a>) <a href="src/Zora-List.html#minimum_with_index" class="link">Source</a></p><div class="doc"><p><em>O(n)</em> Finds the minimum element of the given list and returns a pair of it and the index at which it occurs (if the minimum element occurs multiple times, behavior is identical to that of <code><a href="http://hackage.haskell.org/package/base/docs/Data-List.html#v:minimumBy">minimumBy</a></code>). The list must be finite and non-empty.</p></div></div><div class="top"><p class="src"><a name="v:maxima_by" class="def">maxima_by</a> ::  (a -&gt; a -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ordering">Ordering</a>) -&gt; [a] -&gt; [a] <a href="src/Zora-List.html#maxima_by" class="link">Source</a></p><div class="doc"><p><em>O(n)</em> Finds all maxima of the given list by the given comparator function. For example,
   &gt; maxima_by (Data.Ord.comparing length) [[1,2], [1], [3,3], [2]]
   [[1,2], [3,3]]</p></div></div><div class="top"><p class="src"><a name="v:minima_by" class="def">minima_by</a> ::  (a -&gt; a -&gt; <a href="http://hackage.haskell.org/package/base/docs/Data-Ord.html#t:Ordering">Ordering</a>) -&gt; [a] -&gt; [a] <a href="src/Zora-List.html#minima_by" class="link">Source</a></p><div class="doc"><p><em>O(n)</em> Finds all minima of the given list by the given comparator function. For example,
   &gt; minima_by (Data.Ord.comparing length) [[1,2], [1], [3,3,3], [2]]
   [[1], [2]]</p></div></div><div class="top"><p class="src"><a name="v:length-39-" class="def">length'</a> ::  [a] -&gt; <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> <a href="src/Zora-List.html#length%27" class="link">Source</a></p><div class="doc"><p>Like <code><a href="http://hackage.haskell.org/package/base/docs/Data-List.html#v:length">length</a></code>, but returns an integer.</p></div></div><div class="top"><p class="src"><a name="v:drop-39-" class="def">drop'</a> ::  <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; [a] -&gt; [a] <a href="src/Zora-List.html#drop%27" class="link">Source</a></p><div class="doc"><p>Like <code><a href="http://hackage.haskell.org/package/base/docs/Data-List.html#v:drop">drop</a></code>, but takes an integer.</p></div></div><div class="top"><p class="src"><a name="v:take-39-" class="def">take'</a> ::  <a href="http://hackage.haskell.org/package/base/docs/Prelude.html#t:Integer">Integer</a> -&gt; [a] -&gt; [a] <a href="src/Zora-List.html#take%27" class="link">Source</a></p><div class="doc"><p>Like <code><a href="http://hackage.haskell.org/package/base/docs/Data-List.html#v:take">take</a></code>, but takes an integer.</p></div></div><div class="top"><p class="src"><a name="v:cons" class="def">cons</a> ::  a -&gt; [a] -&gt; [a] <a href="src/Zora-List.html#cons" class="link">Source</a></p><div class="doc"><p>List pre-pending.</p></div></div><div class="top"><p class="src"><a name="v:snoc" class="def">snoc</a> ::  a -&gt; [a] -&gt; [a] <a href="src/Zora-List.html#snoc" class="link">Source</a></p><div class="doc"><p>List appending.</p><pre>snoc 4 [1,2,3] == [1,2,3,4]</pre></div></div><h1 id="g:9">Tuples</h1><div class="top"><p class="src"><a name="v:map_fst" class="def">map_fst</a> ::  (a -&gt; c) -&gt; (a, b) -&gt; (c, b) <a href="src/Zora-List.html#map_fst" class="link">Source</a></p><div class="doc"><p>Applies the given function to the first element of the tuple.</p></div></div><div class="top"><p class="src"><a name="v:map_snd" class="def">map_snd</a> ::  (b -&gt; c) -&gt; (a, b) -&gt; (a, c) <a href="src/Zora-List.html#map_snd" class="link">Source</a></p><div class="doc"><p>Applies the given function to the second element of the tuple.</p></div></div><div class="top"><p class="src"><a name="v:map_pair" class="def">map_pair</a> ::  (a -&gt; c) -&gt; (b -&gt; d) -&gt; (a, b) -&gt; (c, d) <a href="src/Zora-List.html#map_pair" class="link">Source</a></p><div class="doc"><p>Applies the given two functions to the respective first and second elements of the tuple.</p></div></div><div class="top"><p class="src"><a name="v:map_pair_same" class="def">map_pair_same</a> ::  (a -&gt; b) -&gt; (a, a) -&gt; (b, b) <a href="src/Zora-List.html#map_pair_same" class="link">Source</a></p><div class="doc"><p>Applies the given function to the first and second elements of the tuple.</p></div></div><div class="top"><p class="src"><a name="v:map_triple" class="def">map_triple</a> ::  (a -&gt; d) -&gt; (b -&gt; e) -&gt; (c -&gt; f) -&gt; (a, b, c) -&gt; (d, e, f) <a href="src/Zora-List.html#map_triple" class="link">Source</a></p><div class="doc"><p>Applies the given three functions to the respective first, second, and third elements of the tuple.</p></div></div><div class="top"><p class="src"><a name="v:zip_with_pair" class="def">zip_with_pair</a> ::  (a -&gt; c -&gt; e) -&gt; (b -&gt; d -&gt; f) -&gt; (a, b) -&gt; (c, d) -&gt; (e, f) <a href="src/Zora-List.html#zip_with_pair" class="link">Source</a></p><div class="doc"><p>Applies the given function to respectively the first and second elements of the two tuple. For example,</p><pre>zip_with_pair (*) (^) (2,3) (5,4) == (10,27)</pre></div></div><div class="top"><p class="src"><a name="v:zip_with_pair_same" class="def">zip_with_pair_same</a> ::  (a -&gt; b -&gt; c) -&gt; (a, a) -&gt; (b, b) -&gt; (c, c) <a href="src/Zora-List.html#zip_with_pair_same" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Zora-List.html#v:zip_with_pair">zip_with_pair</a></code>, but re-using the same function.</p></div></div><div class="top"><p class="src"><a name="v:fst3" class="def">fst3</a> ::  (a, b, c) -&gt; a <a href="src/Zora-List.html#fst3" class="link">Source</a></p><div class="doc"><p>Extracts the first element of a 3-tuple.</p></div></div><div class="top"><p class="src"><a name="v:snd3" class="def">snd3</a> ::  (a, b, c) -&gt; b <a href="src/Zora-List.html#snd3" class="link">Source</a></p><div class="doc"><p>Extracts the second element of a 3-tuple.</p></div></div><div class="top"><p class="src"><a name="v:trd3" class="def">trd3</a> ::  (a, b, c) -&gt; c <a href="src/Zora-List.html#trd3" class="link">Source</a></p><div class="doc"><p>Extracts the third element of a 3-tuple.</p></div></div><div class="top"><p class="src"><a name="v:pair_op" class="def">pair_op</a> ::  (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c <a href="src/Zora-List.html#pair_op" class="link">Source</a></p><div class="doc"><p>Applies the given binary function to both elements of the given tuple.</p></div></div><div class="top"><p class="src"><a name="v:triple_op" class="def">triple_op</a> ::  (a -&gt; b -&gt; c -&gt; d) -&gt; (a, b, c) -&gt; d <a href="src/Zora-List.html#triple_op" class="link">Source</a></p><div class="doc"><p>Applies the given ternary function to all three elements of the given tuple.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>